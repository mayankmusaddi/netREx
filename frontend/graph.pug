// Import Sigma JS
html
  head
    meta(charset='utf-8')
    script(src='./sigma/sigma.min.js')
    script(src='./sigma/sigma.layout.forceAtlas2.min.js')
    script(src='./sigma/sigma.plugins.filter.js')
    script(src='./sigma/shape-library.js')
    script(src='./sigma/sigma.renderers.customShapes.js')
    script(src='./sigma/sigma.plugins.animate.js')
    script(src='./sigma/sigma.layout.noverlap.js')

    // Add some CSS so we can see the graph!
    style.
      #network-graph {
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      position: fixed;
      }

  body
    // A placeholder for the graph
    #network-graph

script.
  var data = !{JSON.stringify(data)};

  // Add a method to the graph model that returns an object with every neighbors of a node inside:
  sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
      neighbors = {},
      index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
      neighbors[k] = this.nodesIndex[k];

    return neighbors;
  });

  sigma.classes.graph.addMethod('reorderNodes', function (id) {
      var l = this.nodesArray.length;
      var temp = null;
      //remove node from the nodesArray
      for (let i = 0; i < l; i++)
          if (this.nodesArray[i].id === id) {
              temp = this.nodesArray.splice(i, 1);
              break;
          }
      //push the node into the end
      this.nodesArray.push(temp[0]);
      return this;
  });

  s = new sigma({ 
      graph: data,
      container: 'network-graph',
      renderer: {
        container: document.getElementById('network-graph'),
        type: sigma.renderers.canvas
      },
      settings: {
        minNodeSize: 1,
        maxNodeSize: 15,
          //- enableNodeHovering: true, ??
          //- enableEdgeHovering: true, ??
      }
  });

  filter = new sigma.plugins.filter(s);
  var selectedNode;

  var edges = s.graph.edges(); 

  for (var i = 0; i < edges.length; i += 1){
      edges[i].type = 'curve';
      edges[i].size = 0.1;
      edges[i].color = "pink";
  }

  // We first need to save the original colors of our
  // nodes and edges, like this:
  s.graph.nodes().forEach(function(n) {
    n.originalColor = n.color;
    n.originalBorderColor = n.borderColor;
  });
  s.graph.edges().forEach(function(e) {
    e.originalColor = e.color;
  });

  // When a node is clicked, we check for each node if it is a neighbor of the clicked one. If not, we set its color as grey, and else, it takes its original color. We do the same for the edges, and we only keep edges that have both extremities colored.
  s.bind('overNode', function(e) {
    var nodeId = e.data.node.id,
        toKeep = s.graph.neighbors(nodeId);
    toKeep[nodeId] = e.data.node;

    s.graph.nodes().forEach(function(n) {
      if (toKeep[n.id]){
        n.color = n.originalColor;
        n.borderColor = n.originalBorderColor;
        //- s.graph.reorderNodes(n.id); ??
      }
      else{
        n.color = '#eee';
        n.borderColor = '#eee';
      }
    });

      s.graph.edges().forEach(function(e) {
        if (toKeep[e.source] && toKeep[e.target])
          e.color = e.originalColor;
        else
          e.color = '#eee';
      });
      s.refresh()
    });
    // When the stage is clicked, we just color each node and edge with its original color.
    s.bind('outNode', function(e) {
      s.graph.nodes().forEach(function(n) {
        n.color = n.originalColor;
        n.borderColor = n.originalBorderColor;
      });

    s.graph.edges().forEach(function(e) {
      e.color = e.originalColor;
    });

  });


  //Initialize nodes as a circle
  s.graph.nodes().forEach(function(node, i, a) {
      node.x = Math.cos(Math.PI * 2 * i / a.length);
      node.y = Math.sin(Math.PI * 2 * i / a.length);
  });

  //Call refresh to render the new graph
  CustomShapes.init(s);
  s.refresh();

  s.startForceAtlas2();
  setTimeout(
    function () {
      console.log('stopping');
      s.stopForceAtlas2();
    }, 
    1000);

  var config = {
    nodeMargin: 3.0,
    scaleNodes: 1.3,
  };
  // Configure the algorithm
  var listener = s.configNoverlap(config);
  // Bind all events:
  listener.bind('start stop interpolate', function(event) {
    console.log(event.type);
  });
  // Start the algorithm:
  s.startNoverlap();

  //- console.log(data);
  console.log(s.graph.nodes());
  console.log(s.graph.edges());

  if (selectedNode != undefined){
    s.cameras[0].goTo({x:selectedNode['read_cam0:x'],y:selectedNode['read_cam0:y'],ratio:0.1});
  }