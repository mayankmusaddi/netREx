<!-- Import Sigma JS -->
<script src="../sigma/sigma.min.js"></script>
<script src="../sigma/sigma.layout.forceAtlas2.min.js"></script>
<script src="../sigma/sigma.parsers.json.min.js"></script>
<script src="../sigma/sigma.plugins.filter.js"></script>

<!-- Add some CSS so we can see the graph! -->
<style>
  #network-graph {
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    position: absolute;
  }
</style>

<header><meta charset="utf-8"/></header>

<!-- A placeholder for the graph -->
<div id="network-graph"></div>
<body></body>

<!-- The most basic usage of the Sigma JSON parser -->
<script>
  console.log(data);

// var data = JSON.parse("./data/data.json");
// let data = require('./data/data.json');

// console.log(data);
// s = new sigma({ 
//         graph: data,
//         container: 'network-graph',
//         // settings: {
//         //     defaultNodeColor: '#ec5148'
//         // }
// });

// var fdata = data.filter(function(d){
//   return d.nodes.label == "";
// });

// Add a method to the graph model that returns an
// object with every neighbors of a node inside:
sigma.classes.graph.addMethod('neighbors', function(nodeId) {
  var k,
    neighbors = {},
    index = this.allNeighborsIndex[nodeId] || {};

  for (k in index)
    neighbors[k] = this.nodesIndex[k];

  return neighbors;
});

sigma.parsers.json( "/json/drought.json",

{container: 'network-graph',renderer: {
  container: document.getElementById('network-graph'),
  type: sigma.renderers.canvas
}},


function(s) { //This function is passed an instance of Sigma s
  filter = new sigma.plugins.filter(s);

  // nodeId = parseInt(getParameterByName('node_id'));
  var selectedNode;
  // s.graph.nodes().forEach(function(node, i, a) {
    // console.log(node);
    // if (node.id == nodeId) {
      // selectedNode = node;
      // return;
    // }
  // });

  var edges = s.graph.edges(); 
  //Using for loopx
  for (var i = 0; i < edges.length; i += 1){
    // console.log(edges[i])
    edges[i].type = 'curve';
  }
  // filter
  // .edgesBy(function(e) {
  //   return e.size <= 50;
  // }, 'query')
  // .apply();

  // filter
  // .nodesBy(function(n) {
  //   return this.degree(n.id) >= 70;
  // }, 'query2')
  // .apply();

  filter
  .nodesBy(function(n) {
    // return n.label == "Os08g0512400" || n.label == "Os12g0147800";
    return data.query.includes(n.label);
  }, 'query3')
  .apply();


  // We first need to save the original colors of our
    // nodes and edges, like this:
    s.graph.nodes().forEach(function(n) {
      n.originalColor = n.color;
    });
    s.graph.edges().forEach(function(e) {
      e.originalColor = e.color;
    });

    // When a node is clicked, we check for each node
    // if it is a neighbor of the clicked one. If not,
    // we set its color as grey, and else, it takes its
    // original color.
    // We do the same for the edges, and we only keep
    // edges that have both extremities colored.
    s.bind('overNode', function(e) {
      var nodeId = e.data.node.id,
          toKeep = s.graph.neighbors(nodeId);
      toKeep[nodeId] = e.data.node;

      s.graph.nodes().forEach(function(n) {
        if (toKeep[n.id])
          n.color = n.originalColor;
        else
          n.color = '#eee';
      });

      s.graph.edges().forEach(function(e) {
        if (toKeep[e.source] && toKeep[e.target])
          e.color = e.originalColor;
        else
          e.color = '#eee';
      });
      s.refresh()
    });
    // When the stage is clicked, we just color each
    // node and edge with its original color.
    s.bind('outNode', function(e) {
      s.graph.nodes().forEach(function(n) {
        n.color = n.originalColor;
      });

      s.graph.edges().forEach(function(e) {
        e.color = e.originalColor;
      });
    });


  //Initialize nodes as a circle
  s.graph.nodes().forEach(function(node, i, a) {
      node.x = Math.cos(Math.PI * 2 * i / a.length);
      node.y = Math.sin(Math.PI * 2 * i / a.length);
    });
    //Call refresh to render the new graph
    s.refresh();
    s.startForceAtlas2();
    setTimeout(function () {
      console.log('stopping')
      s.stopForceAtlas2()
      }, 3000);
    if (selectedNode != undefined){
      s.cameras[0].goTo({x:selectedNode['read_cam0:x'],y:selectedNode['read_cam0:y'],ratio:0.1});
    }
  }
  );
</script>
