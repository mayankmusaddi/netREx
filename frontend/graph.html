<!-- Import Sigma JS -->
<script src="./sigma/sigma.min.js"></script>
<script src="./sigma/sigma.layout.forceAtlas2.min.js"></script>
<script src="./sigma/sigma.parsers.json.min.js"></script>
<script src="./sigma/sigma.plugins.filter.js"></script>

<!-- Add some CSS so we can see the graph! -->
<style>
  #network-graph {
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    position: absolute;
  }
</style>

<header><meta charset="utf-8"/></header>

<!-- A placeholder for the graph -->
<div id="network-graph"></div>

<body></body>

<script>

// Add a method to the graph model that returns an object with every neighbors of a node inside:
sigma.classes.graph.addMethod('neighbors', function(nodeId) {
  var k,
    neighbors = {},
    index = this.allNeighborsIndex[nodeId] || {};

  for (k in index)
    neighbors[k] = this.nodesIndex[k];

  return neighbors;
});

s = new sigma({ 
    graph: data,
    container: 'network-graph',
    renderer: {
    container: document.getElementById('network-graph'),
    type: sigma.renderers.canvas
  }
    // settings: {
    //     defaultNodeColor: '#ec5148'
    // }
});

filter = new sigma.plugins.filter(s);
var selectedNode;

var edges = s.graph.edges(); 
for (var i = 0; i < edges.length; i += 1){
    edges[i].type = 'curve';
}
// filter
// .edgesBy(function(e) {
//   return e.size <= 50;
// }, 'query')
// .apply();

// filter
// .nodesBy(function(n) {
//   return this.degree(n.id) >= 70;
// }, 'query2')
// .apply();


// We first need to save the original colors of our
// nodes and edges, like this:
s.graph.nodes().forEach(function(n) {
  n.originalColor = n.color;
});
s.graph.edges().forEach(function(e) {
  e.originalColor = e.color;
});

// When a node is clicked, we check for each node if it is a neighbor of the clicked one. If not, we set its color as grey, and else, it takes its original color. We do the same for the edges, and we only keep edges that have both extremities colored.
s.bind('overNode', function(e) {
  var nodeId = e.data.node.id,
      toKeep = s.graph.neighbors(nodeId);
  toKeep[nodeId] = e.data.node;

  s.graph.nodes().forEach(function(n) {
    if (toKeep[n.id])
      n.color = n.originalColor;
    else
      n.color = '#eee';
  });

    s.graph.edges().forEach(function(e) {
      if (toKeep[e.source] && toKeep[e.target])
        e.color = e.originalColor;
      else
        e.color = '#eee';
    });
    s.refresh()
  });
  // When the stage is clicked, we just color each node and edge with its original color.
  s.bind('outNode', function(e) {
    s.graph.nodes().forEach(function(n) {
      n.color = n.originalColor;
    });

  s.graph.edges().forEach(function(e) {
    e.color = e.originalColor;
  });
});


//Initialize nodes as a circle
s.graph.nodes().forEach(function(node, i, a) {
    node.x = Math.cos(Math.PI * 2 * i / a.length);
    node.y = Math.sin(Math.PI * 2 * i / a.length);
});

//Call refresh to render the new graph
s.refresh();

s.startForceAtlas2();
setTimeout(
  function () {
    console.log('stopping');
    s.stopForceAtlas2();
  }, 
  2000);

console.log(data);

if (selectedNode != undefined){
  s.cameras[0].goTo({x:selectedNode['read_cam0:x'],y:selectedNode['read_cam0:y'],ratio:0.1});
}

</script>
